# Asymtetric Cryptography ECDSA

I apologize in advance for the opprobrious content of the README file, but I wanted to describe each step in reasonable detail showing my deep understanding of the subject.

## FACILITIES

### 1.	Generating a pseudorandom number

At this stage, at least several random numbers are generated by various means. At first, an n-bit string is drawn. The user can choose between a 128-bit and a 256-bit entropy. The length of the entropy also translates into the length of the seed phrase, but more on that later.

Then, using the Xoroshiro128 encryption method, another number is drawn. This number is the mixing instruction of the first entropy. This instruction is very similar to the method of generating a public key in the DH (Diffie Helman) system, where the bits (0-1) decide whether to perform one or 2 transformations. In my case, the number generated by Xoroshiro128 will determine the mixing of the entropy generated earlier. If the bit of the number Xoroshiro128 will be 0 then we do not mix, if 1 then we mix. There may be several bits, so mixing may occur even several times. By mentioning mixing I generally mean the shufle method.

On the issue of entropy generation, which is crucial for cryptographic asymmetry, I still have a bit to work out. Even though I would mix and blend the number generated by the algorithm, it will still only be a PSEUDO random number, which, if enough numbers are generated, can be predicted in some way. Improving this step will be an attempt to create a real random number. Usually used for this is the tracking of the mouse, which the user is asked to move. However, I do not want to go into traditional solutions, so I think that in the future I would like users to tell a little about themselves, maybe choose some colors, favorite premiods, sports etc.

### 2.	Hashing method

The hashing method is used in many important places in my application. The hash will primarily be the private key and any other entropy. I have chosen the SHA 256 hash method. Any string passed through this algorithm will create a unique 256-bit hash. Is this enough? For the sake of comparison, let me add that in terms of security, the 256-bit key in the ECDSA model is comparable to the 3072-bit key for the RSA model. Below is an interesting comparison:

 Symetrci Key Size (bits) | RSA and DH Key Size (bits) | Eliptic Curve Key Size (bits) | 
| ------------------------|----------------------------|-------------------------------|
| 80                      |	1024                     	 | 160                           |
| 112         	          | 2048                       | 224                         	 |
| 128                   	| 3072                       | 256	                         |
| 192                     | 7680                       | 384                           |
| 256                     | 15360                      | 521                           |




